# SafeGuard Database Documentation

## üìã Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Core Tables](#core-tables)
- [Relationships](#relationships)
- [Functions](#functions)
- [Triggers](#triggers)
- [Views](#views)
- [Security](#security)
- [Performance](#performance)
- [Usage Examples](#usage-examples)
- [Maintenance](#maintenance)

---

## üèóÔ∏è Overview

The SafeGuard database implements a **visit-centric visitor management system** for gated communities and residential buildings. The core philosophy is that **visits (not individual visitors) receive QR codes**, and multiple visitors can be associated with a single visit.

### Key Concepts
- **Buildings** have 250 licenses by default (for registered users, not visitors)
- **Users** can create unlimited visitors per month
- **Visits** are the primary entity that gets QR codes
- **Visitors** are reusable profiles stored per building
- **QR codes** contain visit information and are generated by business logic after visit creation

---

## üèõÔ∏è Architecture

### Database Design Principles
1. **Visit-Centric**: Everything revolves around visits, not individual visitors
2. **Reusable Profiles**: Visitor profiles can be reused across multiple visits
3. **License Management**: Only registered users count against building licenses
4. **Security-First**: Comprehensive audit trails and multi-level access control
5. **Performance-Optimized**: Strategic indexing and materialized views
6. **Schema Separation**: Logical organization with dedicated schemas for different domains
7. **Profile Management**: Extended user profiles with approval workflows

### Technology Stack
- **Database**: PostgreSQL 12+
- **Extensions**: uuid-ossp, postgis (optional for location features)
- **Features**: Row Level Security, Triggers, Materialized Views, Custom Types
- **Schema Organization**: Multi-schema architecture for better maintainability

### Schema Organization (Planned v2.0)
```
safeguard_db
‚îú‚îÄ‚îÄ public                    # Core system tables
‚îú‚îÄ‚îÄ profile_management        # User profiles and registration workflows
‚îú‚îÄ‚îÄ building_management       # Buildings, licenses, and admin operations
‚îî‚îÄ‚îÄ visitor_management        # Visitor and visit management
```

---

## üìä Core Tables

### 1. Buildings (`buildings`)
**Purpose**: Represents physical buildings/estates in the system

```sql
Key Fields:
- id (UUID, PK): Unique building identifier
- name, address, city, state, country: Building details
- total_licenses (INT): Total user licenses (default: 250)
- used_licenses (INT): Currently used licenses (auto-calculated)
- location (POINT): GPS coordinates for geofencing
- is_active (BOOLEAN): Building status
```

**Business Rules**:
- Each building gets 250 licenses by default
- Only active registered users count against licenses
- Visitors don't consume licenses

### 2. Users (`users`)
**Purpose**: Registered users in the system (residents, admins, security)

```sql
Key Fields:
- id (UUID, PK): Unique user identifier
- building_id (UUID, FK): Reference to building
- email (VARCHAR, UNIQUE): Login email
- role (user_role): 'super_admin', 'building_admin', 'resident', 'security', 'visitor'
- uses_license (BOOLEAN): Whether user counts against building licenses
- apartment_number (VARCHAR): Resident's apartment
- is_active (BOOLEAN): User status
- last_login (TIMESTAMPTZ): Most recent successful login timestamp
- last_login_ip (INET): IP address from most recent successful login
- last_user_agent (TEXT): User agent string from most recent successful login
- login_attempts (INTEGER): Failed login attempt counter (security feature)
- locked_until (TIMESTAMPTZ): Account lockout timestamp for security
```

**Business Rules**:
- Residents and admins use licenses by default
- Security and temporary users may not use licenses
- Enhanced authentication tracking for security monitoring
- Account lockout mechanism after failed login attempts
- Email must be unique across the entire system
- Enhanced login tracking for security and analytics

### 3. Visitors (`visitors`)
**Purpose**: Reusable visitor profiles per building

```sql
Key Fields:
- id (UUID, PK): Unique visitor identifier
- building_id (UUID, FK): Reference to building
- created_by (UUID, FK): User who first registered this visitor
- name, phone, email: Visitor contact details
- is_frequent (BOOLEAN): Auto-updated based on visit history
- visit_count (INT): Total number of visits
- rating (DECIMAL): Average rating from hosts
```

**Business Rules**:
- One visitor profile per phone number per building
- Profiles are reusable across multiple visits
- Automatically marked as frequent if visit_count >= 5

### 4. Visits (`visits`) üéØ **CORE TABLE**
**Purpose**: The primary entity that receives QR codes and manages visitor access

```sql
Key Fields:
- id (UUID, PK): Unique visit identifier
- building_id (UUID, FK): Reference to building
- host_id (UUID, FK): User hosting the visit
- title (VARCHAR): Visit description ("Business Meeting", "Birthday Party")
- visit_type (visit_type): 'single', 'group', 'recurring'
- qr_code (TEXT, UNIQUE): Generated QR code string
- qr_code_data (JSONB): Encrypted visit details for QR
- status (visit_status): 'pending', 'confirmed', 'active', 'completed', 'cancelled', 'expired'
- expected_start/end (TIMESTAMPTZ): Planned visit times
- current_visitors (INT): Number of visitors added to this visit
- max_visitors (INT): Maximum allowed visitors
- entry (BOOLEAN): QR code scanned at building entry (Version 2)
- exit (BOOLEAN): QR code scanned at building exit (Version 2)
```

**Business Rules**:
- QR codes are generated AFTER visit creation by business logic
- One QR code per visit, regardless of visitor count
- Status automatically transitions based on visitor actions
- **Version 2**: Entry and exit tracking via separate QR scans
- **Sequential Validation**: Cannot exit without entry scan first
- **Security Role Only**: Only security personnel can scan QR codes for entry/exit

### 5. Visit Visitors (`visit_visitors`)
**Purpose**: Junction table linking visits to multiple visitors

```sql
Key Fields:
- visit_id (UUID, FK): Reference to visit
- visitor_id (UUID, FK): Reference to visitor
- status (VARCHAR): 'expected', 'arrived', 'entered', 'exited'
- arrival_time, departure_time (TIMESTAMPTZ): Actual times
- added_by (UUID, FK): User who added this visitor to the visit
```

**Business Rules**:
- Multiple visitors can be added to one visit
- Each visitor has individual status tracking within the visit
- Automatic triggers update visit completion status

### 6. Frequent Visitors (`frequent_visitors`)
**Purpose**: User's personal favorites list for quick access

```sql
Key Fields:
- user_id (UUID, FK): Reference to user
- visitor_id (UUID, FK): Reference to visitor
- nickname (VARCHAR): Custom name for this relationship
- relationship (VARCHAR): 'family', 'friend', 'colleague', 'service_provider'
- priority (INT): 1-5 priority ranking (1 = highest)
```

### 7. Visitor Bans (`visitor_bans`) üö´ **PHONE-CENTRIC BAN SYSTEM**
**Purpose**: Advanced phone-centric visitor restriction system with personal blacklists

```sql
Key Fields:
- id (UUID, PK): Unique ban identifier
- building_id (UUID, FK): Reference to building  
- user_id (UUID, FK): User who created the ban
- name (VARCHAR): Visitor's name (stored directly)
- phone (VARCHAR): Visitor's phone number (primary identifier)
- reason (TEXT): Why visitor was banned
- severity (ban_severity): 'low', 'medium', 'high' - escalation levels
- ban_type (ban_type): 'manual' (user-created) or 'automatic' (system-generated)
- is_active (BOOLEAN): Current ban status
- banned_at (TIMESTAMPTZ): When ban was created
- expires_at (TIMESTAMPTZ): When ban expires (NULL for permanent)
- unbanned_at (TIMESTAMPTZ): When ban was lifted
- unban_reason (TEXT): Why ban was removed
- unbanned_by (UUID, FK): Who removed the ban
- notes (TEXT): Additional context
- trigger_event (VARCHAR): For automatic bans - what triggered it
- metadata (JSONB): Extensible data storage
```

**Business Rules**:
- **Phone-Centric**: Bans target phone numbers directly, not visitor profiles
- **Personal Blacklists**: Each resident maintains their own ban list
- **Building-wide Visibility**: Residents can see if others have banned the same visitor
- **Severity Escalation**: low ‚Üí medium ‚Üí high based on incidents
- **Temporary Bans**: Automatic expiry with `expires_at` field
- **Complete Audit Trail**: Full tracking of ban creation, updates, and removal
- **Flexible Storage**: Direct phone/name storage eliminates visitor profile dependencies

**Key Features**:
1. **Individual Control**: Residents can ban visitors independently
2. **Cross-resident Awareness**: Check if visitor is banned by others in building
3. **Automatic Expiry**: Temporary bans with configurable duration
4. **Severity Levels**: Escalating restriction levels (low/medium/high)
5. **Unban Tracking**: Complete audit trail for ban removal
6. **Performance Optimized**: Direct phone lookups without JOINs

### 8. System Blacklist (`system_blacklist`)
**Purpose**: Building-wide restrictions managed by admins and security

**System Bans**:
- Building-wide restrictions
- Managed by admins and security
- Affects all residents in the building

### 8. Visit Logs (`visit_logs`)
**Purpose**: Detailed tracking of all visitor actions

```sql
Key Fields:
- visit_id (UUID, FK): Reference to visit
- visitor_id (UUID, FK): Reference to visitor (nullable for visit-level actions)
- action (VARCHAR): 'qr_scanned', 'arrived', 'entered', 'exited', 'departed'
- timestamp (TIMESTAMPTZ): When action occurred
- security_officer (UUID, FK): Officer who processed the action
- gate_number (VARCHAR): Which gate was used
```

### 9. Notifications (`notifications`)
**Purpose**: Real-time messaging system

```sql
Key Fields:
- user_id (UUID, FK): Recipient
- visit_id (UUID, FK): Related visit (nullable)
- visitor_id (UUID, FK): Related visitor (nullable)
- type (notification_type): 'visit_created', 'visitor_arrival', 'emergency', etc.
- is_read (BOOLEAN): Read status
- priority (INT): 1-5 priority level
```

### 10. Resident Approval System ‚úÖ **IMPLEMENTED**

#### Resident Approval Requests (`resident_approval_requests`)
**Purpose**: Complete registration approval workflow for new residents

```sql
Key Fields:
- id (UUID, PK): Unique approval request identifier
- user_id (UUID, FK): Reference to user account (created with is_active=false)
- building_id (UUID, FK): Reference to building
- request_type (VARCHAR): Type of approval ('resident_registration')
- status (VARCHAR): 'pending', 'approved', 'rejected', 'expired'
- registration_data (JSONB): Complete registration form data
- approved_by (UUID, FK): Building admin who processed the request
- approved_at (TIMESTAMPTZ): When request was processed
- rejection_reason (TEXT): Admin feedback for rejections
- approval_notes (TEXT): Additional admin notes
- created_at (TIMESTAMPTZ): When approval request was created
- updated_at (TIMESTAMPTZ): Last modification timestamp
- expires_at (TIMESTAMPTZ): Auto-expiry date (30 days from creation)
```

**Business Rules**:
- Created automatically when resident self-registers
- User account created with `is_active = false` until approved
- Building admins can approve/reject requests for their building only
- Auto-expires after 30 days if no action taken
- Complete audit trail of approval decisions
- Approved users become active and can login immediately
- Rejected users remain inactive and cannot access system

**Database Schema**:
```sql
CREATE TABLE resident_approval_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  building_id UUID NOT NULL REFERENCES buildings(id) ON DELETE CASCADE,
  request_type VARCHAR(50) DEFAULT 'resident_registration',
  status VARCHAR(20) DEFAULT 'pending',
  registration_data JSONB DEFAULT '{}',
  approved_by UUID REFERENCES users(id) ON DELETE SET NULL,
  approved_at TIMESTAMP,
  rejection_reason TEXT,
  approval_notes TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '30 days'),
  
  -- Constraints
  CONSTRAINT unique_user_approval UNIQUE(user_id),
  CONSTRAINT check_status CHECK (status IN ('pending', 'approved', 'rejected', 'expired'))
);

-- Performance Indexes
CREATE INDEX idx_resident_approval_building_status ON resident_approval_requests (building_id, status);
CREATE INDEX idx_resident_approval_user ON resident_approval_requests (user_id);
CREATE INDEX idx_resident_approval_expires ON resident_approval_requests (expires_at);
CREATE INDEX idx_resident_approval_created ON resident_approval_requests (created_at);
```

### 11. Profile Management System (Planned v3.0)

#### Extended User Profiles (`profile_management.user_profiles`)
**Purpose**: Enhanced user profile data beyond basic account information

```sql
Key Fields:
- user_id (UUID, FK): Reference to core user account
- avatar_url (TEXT): Profile picture URL
- bio (TEXT): User biography (max 500 chars)
- date_of_birth (DATE): For age verification
- emergency_contact (JSONB): Emergency contact information
- notification_preferences (JSONB): Email, push, alert preferences
- privacy_settings (JSONB): Visibility and sharing controls
- theme_preferences (JSONB): UI theme and language settings
```

#### License Allocations (`building_management.license_allocations`)
**Purpose**: Track license assignments by building admins

```sql
Key Fields:
- building_id, user_id: License assignment
- allocated_by (UUID, FK): Admin who assigned license
- allocation_method (ENUM): 'admin', 'auto', 'system'
- expires_at (TIMESTAMPTZ): License expiry date
- is_active (BOOLEAN): Current license status
```

### 11. Supporting Tables
- **`licenses`**: Building subscription management
- **`payments`**: Payment processing tracking
- **`emergency_alerts`**: Security incident management
- **`audit_logs`**: Comprehensive security audit trail
- **`user_sessions`**: JWT token management
- **`analytics_events`**: Real-time analytics data collection

---

## üîó Relationships

### Primary Relationships
```
buildings (1) ‚Üê (M) users
buildings (1) ‚Üê (M) visitors
buildings (1) ‚Üê (M) visits
users (1) ‚Üê (M) visits (as host)
users (1) ‚Üê (M) visitors (as creator)
visits (M) ‚Üê (M) visitors (via visit_visitors)
users (1) ‚Üê (M) frequent_visitors
```

### Key Foreign Key Constraints
- All major tables reference `buildings` for data isolation
- `visits.host_id` ‚Üí `users.id` (who's hosting)
- `visitors.created_by` ‚Üí `users.id` (who registered the visitor)
- `visit_visitors` creates M:M between visits and visitors

---

## ‚öôÔ∏è Functions

### Core Business Logic Functions

#### 1. `create_visit_with_visitors()`
**Purpose**: Creates a visit and adds multiple visitors in a transaction

```sql
SELECT * FROM create_visit_with_visitors(
    p_building_id UUID,
    p_host_id UUID,
    p_title VARCHAR(255),
    p_description TEXT,
    p_expected_start TIMESTAMP WITH TIME ZONE,
    p_expected_end TIMESTAMP WITH TIME ZONE,
    p_visitors JSONB, -- Array of visitor objects
    p_visit_type visit_type DEFAULT 'single'
);

-- Returns: success, visit_id, qr_code, message, visitor_count
```

**What it does**:
1. Checks building license availability
2. Creates a new visit record
3. Generates QR code data (encrypted visit details)
4. Processes visitor array (creates new or uses existing profiles)
5. Checks ban status for each visitor
6. Links visitors to visit via `visit_visitors`
7. Returns complete visit information

#### 2. `process_qr_scan()`
**Purpose**: Handles QR code scanning at building gates

```sql
SELECT * FROM process_qr_scan(
    p_qr_code TEXT,
    p_gate_number VARCHAR(20) DEFAULT NULL,
    p_security_officer UUID DEFAULT NULL,
    p_location POINT DEFAULT NULL
);

-- Returns: success, message, visit_data, visitors (array)
```

**What it does**:
1. Validates QR code and expiration
2. Retrieves visit and all associated visitors
3. Updates visit status to 'active' if first scan
4. Logs the QR scan action
5. Creates notification for host
6. Returns complete visit and visitor information

#### 3. `update_visit_visitor_status()`
**Purpose**: Updates individual visitor status within a visit

```sql
SELECT * FROM update_visit_visitor_status(
    p_visit_id UUID,
    p_visitor_id UUID,
    p_new_status VARCHAR(50), -- 'arrived', 'entered', 'exited'
    p_security_officer UUID DEFAULT NULL,
    p_location POINT DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
);
```

**What it does**:
1. Validates status transition
2. Updates visitor status in `visit_visitors`
3. Sets timestamps (arrival_time, departure_time)
4. Logs the action in `visit_logs`
5. Updates visitor's total visit count if entering

#### 4. `get_or_create_visitor()`
**Purpose**: Finds existing visitor or creates new profile

```sql
SELECT get_or_create_visitor(
    p_building_id UUID,
    p_created_by UUID,
    p_name VARCHAR(255),
    p_phone VARCHAR(20),
    p_email VARCHAR(255) DEFAULT NULL
) RETURNS UUID;
```

**What it does**:
1. Searches for existing visitor by building + phone
2. If found, updates information and returns ID
3. If not found, creates new visitor profile
4. Enforces unique constraint per building

#### 5. Phone-Centric Ban Checking Functions üö´
**Purpose**: Advanced ban checking for phone-centric visitor restriction system

##### `is_visitor_banned_by_phone()`
```sql
SELECT is_visitor_banned_by_phone(
    p_building_id UUID,
    p_user_id UUID,
    p_phone VARCHAR(20)
) RETURNS BOOLEAN;
```

**What it does**:
1. Formats phone number for consistency
2. Checks personal bans (`visitor_bans`) by phone
3. Checks system-wide bans (`system_blacklist`) by phone  
4. Considers ban expiration dates and active status
5. Returns true if visitor is banned at any level

##### `is_visitor_banned_by_user()`
```sql
SELECT is_visitor_banned_by_user(
    p_user_id UUID,
    p_phone TEXT
) RETURNS BOOLEAN;
```

**What it does**:
1. Checks if specific user has banned this phone number
2. Considers only active bans with valid expiration
3. Used for personal blacklist checking

##### `is_visitor_banned_in_building()`
```sql
SELECT is_visitor_banned_in_building(
    p_building_id UUID,
    p_phone TEXT
) RETURNS BOOLEAN;
```

**What it does**:
1. Checks if any resident in building has banned this phone number
2. Returns true if visitor is banned by anyone in the building
3. Used for building-wide ban visibility

##### `format_phone_number()`
```sql
SELECT format_phone_number(phone_input TEXT) RETURNS TEXT;
```

**What it does**:
1. Standardizes phone number format for consistency
2. Adds +234 prefix for Nigerian numbers
3. Removes non-digit characters except +
4. Ensures uniform storage and comparison

##### `expire_visitor_bans()`
```sql
SELECT expire_visitor_bans() RETURNS INTEGER;
```

**What it does**:
1. Automatically expires temporary bans past their expiry date
2. Sets `is_active = false` and records unban details
3. Returns count of expired bans
4. Intended for automated/scheduled execution

### Analytics Functions

#### 6. `get_building_analytics()`
**Purpose**: Comprehensive building statistics

```sql
SELECT * FROM get_building_analytics(
    p_building_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE,
    p_end_date TIMESTAMP WITH TIME ZONE
);

-- Returns: total_visits, total_visitors, avg_visit_duration, 
--          peak_hour, most_active_host, visit_completion_rate
```

#### 7. `get_visitor_recommendations()`
**Purpose**: AI-powered visitor suggestions

```sql
SELECT * FROM get_visitor_recommendations(
    p_user_id UUID,
    p_limit INTEGER DEFAULT 10
);
```

**Scoring Algorithm**:
- Frequent status: +100 points
- Recent visits (30 days): +50 points
- Recent visits (90 days): +25 points
- Each visit: +5 points
- Rating: +(rating * 10) points

### Utility Functions

#### 8. `generate_qr_code_data()`
**Purpose**: Creates QR code payload with visit details

#### 9. `check_license_availability()`
**Purpose**: Validates if building has available licenses

#### 10. `add_to_frequent_visitors()`
**Purpose**: Adds visitor to user's favorites list

#### 11. `create_emergency_alert()`
**Purpose**: Emergency notification system

#### 12. `daily_maintenance()`
**Purpose**: Automated maintenance tasks

### Resident Approval Functions ‚úÖ **IMPLEMENTED**

#### 13. `process_resident_approval()`
**Purpose**: Processes resident approval requests (approve/reject)

```sql
SELECT * FROM process_resident_approval(
    p_approval_id UUID,
    p_admin_id UUID,
    p_approved BOOLEAN,
    p_reason TEXT DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
);

-- Returns: success, message, user_id, approval_status
```

**What it does**:
1. Validates approval request exists and is pending
2. Checks admin has permission for the building
3. Updates approval status and timestamps
4. Activates/deactivates user account based on decision
5. Records admin who processed the request
6. Creates audit trail of the decision

#### 14. `get_building_approval_statistics()`
**Purpose**: Building-wide approval statistics for dashboards

```sql
SELECT * FROM get_building_approval_statistics(
    p_building_id UUID,
    p_start_date TIMESTAMP DEFAULT (CURRENT_DATE - INTERVAL '30 days'),
    p_end_date TIMESTAMP DEFAULT CURRENT_DATE
);

-- Returns: total_requests, pending, approved, rejected, expired, avg_processing_time
```

**What it does**:
1. Aggregates approval request statistics for date range
2. Calculates approval rates and processing times
3. Provides data for building admin dashboards
4. Tracks approval workflow efficiency

#### 15. `expire_approval_requests()`
**Purpose**: Automatically expires old pending approval requests

```sql
SELECT expire_approval_requests() RETURNS INTEGER;
```

**What it does**:
1. Finds approval requests older than 30 days with pending status
2. Updates status to 'expired'
3. Optionally deactivates associated user accounts
4. Returns count of expired requests
5. Intended for automated/scheduled execution

---

## üîÑ Triggers

### Automatic Timestamp Management
```sql
-- Updates updated_at fields automatically
tr_[table]_updated_at: update_updated_at()
```
Applied to: `buildings`, `users`, `visitors`, `visits`, `frequent_visitors`, etc.

### License Management
```sql
-- Automatically tracks building license usage
tr_user_license_count: update_building_license_count()
```
**Behavior**:
- Increments `buildings.used_licenses` when user with `uses_license=true` is created
- Decrements when such user is deleted or moved
- Handles building transfers

### Visit Management
```sql
-- Updates visit visitor counts
tr_visit_visitor_count: update_visit_visitor_count()
```
**Behavior**:
- Increments `visits.current_visitors` when visitor added
- Decrements when visitor removed
- Handles visitor transfers between visits

### Auto-Completion
```sql
-- Automatically completes visits when all visitors exit
tr_auto_complete_visits: auto_complete_visits()
```
**Behavior**:
- Monitors `visit_visitors` status changes
- When all visitors have 'exited', marks visit as 'completed'
- Sets `actual_end` timestamp

### Security Auditing
```sql
-- Comprehensive audit logging
tr_[table]_audit: create_audit_log()
```
**Behavior**:
- Logs all CREATE, UPDATE, DELETE operations
- Captures before/after values
- Records user context and timestamps
- Applied to critical tables: `users`, `visits`, `visitors`, `visitor_bans`

### Analytics Collection
```sql
-- Real-time analytics data capture
tr_[table]_analytics: create_analytics_event()
```
**Behavior**:
- Captures business events (visit created, status changed, user login)
- Feeds real-time dashboard
- Enables pattern analysis

### Resident Approval Triggers ‚úÖ **IMPLEMENTED**

#### Approval Request Expiry
```sql
-- Automatically expires old approval requests
tr_approval_expiry: expire_approval_requests()
```
**Behavior**:
- Runs daily via maintenance job
- Marks requests older than 30 days as 'expired'
- Updates associated user accounts if needed
- Maintains clean approval queue

#### User Status Updates
```sql
-- Updates user is_active status based on approval decisions
tr_approval_user_status: update_user_activation_status()
```
**Behavior**:
- Triggered when approval status changes
- Sets user.is_active = true when approved
- Sets user.is_active = false when rejected
- Maintains user account state consistency

#### Approval Audit Trail
```sql
-- Comprehensive audit logging for approval decisions
tr_approval_audit: create_approval_audit_log()
```
**Behavior**:
- Logs all approval decision changes
- Records admin who processed the request
- Captures before/after states
- Enables compliance and audit requirements

---

## üìä Views

### 1. `visit_summary`
**Purpose**: Complete visit information with visitor details
```sql
SELECT * FROM visit_summary WHERE building_id = ?;
```
**Includes**: Visit details, host info, building info, visitor array (JSON)

### 2. `building_stats`
**Purpose**: Real-time building dashboard
```sql
SELECT * FROM building_stats WHERE building_id = ?;
```
**Includes**: License usage, resident count, visit statistics, emergency status

### 3. `user_activity_dashboard`
**Purpose**: User engagement metrics
```sql
SELECT * FROM user_activity_dashboard WHERE user_id = ?;
```
**Includes**: Visit counts, visitor relationships, notification status, online status

### 4. `visit_analytics`
**Purpose**: Time-series visit data for charts
```sql
SELECT * FROM visit_analytics 
WHERE building_id = ? AND visit_date >= ?
ORDER BY visit_date;
```
**Includes**: Daily aggregates, completion rates, visitor counts

### 5. `security_monitoring`
**Purpose**: Security dashboard for admins
```sql
SELECT * FROM security_monitoring WHERE building_id = ?;
```
**Includes**: Ban counts, active emergencies, overdue visits, audit events

### 6. Visitor Ban Views üö´

#### `active_visitor_bans`
**Purpose**: Active visitor bans only (filtered view)
```sql
SELECT * FROM active_visitor_bans WHERE building_id = ?;
```
**Includes**: All active bans with complete ban details (excludes expired/inactive bans)

#### `building_ban_stats`
**Purpose**: Building-wide ban statistics and analytics
```sql
SELECT * FROM building_ban_stats WHERE building_id = ?;
```
**Includes**: 
- Total bans, active bans, severity breakdown
- Unique banned visitors count
- Users who have created bans
- Last ban date for trending

#### `user_ban_stats`
**Purpose**: Per-user ban statistics for residents
```sql
SELECT * FROM user_ban_stats WHERE user_id = ?;
```
**Includes**:
- Individual resident ban activity
- Total bans created, active bans
- High severity ban count
- Unique visitors banned
- First and last ban dates

### Materialized Views

#### `daily_visit_stats`
**Purpose**: Pre-computed daily statistics for performance
```sql
-- Refreshed automatically by daily maintenance
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_visit_stats;
```

---

## üîê Security

### Row Level Security (RLS)
**Enabled on**: `visits`, `visitors`, `notifications`, `frequent_visitors`, `visitor_bans`

#### Visit Access Policy
```sql
-- Users can only see their own visits or building visits if admin
CREATE POLICY visit_access_policy ON visits
USING (
    host_id = current_user_id() OR 
    building_id IN (
        SELECT building_id FROM users 
        WHERE id = current_user_id() 
        AND role IN ('building_admin', 'security', 'super_admin')
    )
);
```

#### Visitor Access Policy
```sql
-- Users can only see visitors from their building
CREATE POLICY visitor_access_policy ON visitors
USING (
    building_id IN (
        SELECT building_id FROM users 
        WHERE id = current_user_id()
    )
);
```

### User Context Function
```sql
-- Set by application for RLS policies
SELECT set_config('app.current_user_id', user_id::text, true);
```

### Authentication Role
```sql
-- Application users must have this role
GRANT authenticated_users TO application_user;
```

---

## ‚ö° Performance

### Strategic Indexing
```sql
-- Core performance indexes
idx_visits_building_status (building_id, status)
idx_visits_qr_code (qr_code) -- Critical for gate scanning
idx_visitors_building_phone (building_id, phone) -- Visitor lookup
idx_visit_logs_timestamp (timestamp) -- Analytics queries
idx_notifications_user_unread (user_id, is_read) WHERE is_read = false
```

### Query Optimization
- **Composite indexes** for common filter combinations
- **Partial indexes** for filtered queries (e.g., unread notifications)
- **JSON indexes** for metadata searches (if needed)

### Materialized Views
- `daily_visit_stats`: Pre-computed daily aggregates
- Refreshed by `daily_maintenance()` function
- Enables fast dashboard loading

### Connection Recommendations
- **Connection pooling** (PgBouncer recommended)
- **Read replicas** for analytics queries
- **Partitioning** for high-volume tables (future consideration)

---

## üí° Usage Examples

### Creating a Visit with Multiple Visitors
```sql
-- Host creates a group visit
SELECT * FROM create_visit_with_visitors(
    'building-uuid-here',
    'host-user-uuid',
    'Birthday Party',
    'Family birthday celebration for Sarah',
    '2024-01-20 15:00:00+01',
    '2024-01-20 22:00:00+01',
    '[
        {
            "name": "John Doe", 
            "phone": "+2348123456789", 
            "email": "john@example.com"
        },
        {
            "name": "Jane Smith", 
            "phone": "+2348987654321", 
            "email": "jane@example.com"
        },
        {
            "name": "Bob Wilson", 
            "phone": "+2348555666777"
        }
    ]'::jsonb,
    'group'
);

-- Returns QR code that covers all 3 visitors
```

### Gate Processing Workflow
```sql
-- 1. Security scans QR code
SELECT * FROM process_qr_scan('SG_ABC123DEF456', 'Gate A', security_officer_uuid);

-- Returns visit info + all expected visitors:
-- {
--   "visit_data": {
--     "visit_id": "...",
--     "title": "Birthday Party",
--     "host_name": "John Resident",
--     "apartment_number": "A101"
--   },
--   "visitors": [
--     {"name": "John Doe", "status": "expected"},
--     {"name": "Jane Smith", "status": "expected"}, 
--     {"name": "Bob Wilson", "status": "expected"}
--   ]
-- }

-- 2. Individual visitors arrive and enter
SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'arrived', 
    security_officer_uuid
);

SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'entered', 
    security_officer_uuid
);

-- 3. Visitors leave individually
SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'exited', 
    security_officer_uuid
);

-- 4. Visit auto-completes when all visitors exit
```

### Adding to Frequent Visitors
```sql
-- After a successful visit, host can save visitor to favorites
SELECT add_to_frequent_visitors(
    host_user_uuid,
    visitor_uuid,
    'My Brother John',
    'family',
    1  -- highest priority
);

-- Next time, host can quickly invite from favorites list
SELECT * FROM get_visitor_recommendations(host_user_uuid, 10);
```

### Visitor Ban Management Examples üö´

#### Creating and Managing Bans
```sql
-- Create a visitor ban (would be done via API, shown for reference)
INSERT INTO visitor_bans (building_id, user_id, name, phone, reason, severity, ban_type, notes)
VALUES (
    'building-uuid',
    'user-uuid', 
    'John Problem Visitor',
    '+2348123456789',
    'Inappropriate behavior during last visit',
    'medium',
    'manual',
    'Resident requested permanent ban due to security concerns'
);

-- Check if visitor is banned by specific user
SELECT is_visitor_banned_by_user('user-uuid', '+2348123456789');

-- Check if visitor is banned anywhere in building
SELECT is_visitor_banned_in_building('building-uuid', '+2348123456789');

-- Create temporary ban with expiry
INSERT INTO visitor_bans (building_id, user_id, name, phone, reason, severity, expires_at)
VALUES (
    'building-uuid',
    'user-uuid',
    'Jane Temp Ban',
    '+2348987654321', 
    'Noise complaints from neighbors',
    'low',
    CURRENT_TIMESTAMP + INTERVAL '7 days'
);

-- Manually unban a visitor
UPDATE visitor_bans 
SET is_active = false,
    unbanned_at = CURRENT_TIMESTAMP,
    unban_reason = 'Issue resolved, apology accepted',
    unbanned_by = 'unbanning-user-uuid'
WHERE phone = '+2348123456789' 
AND user_id = 'banning-user-uuid'
AND is_active = true;
```

#### Ban Analytics and Monitoring
```sql
-- Get building ban statistics
SELECT * FROM building_ban_stats WHERE building_id = ?;

-- Get user's ban activity
SELECT * FROM user_ban_stats WHERE user_id = ?;

-- Monitor ban trends
SELECT 
    DATE(banned_at) as ban_date,
    COUNT(*) as bans_created,
    COUNT(*) FILTER (WHERE severity = 'high') as high_severity,
    COUNT(DISTINCT phone) as unique_visitors_banned
FROM visitor_bans 
WHERE building_id = ? 
AND banned_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(banned_at)
ORDER BY ban_date DESC;

-- Find visitors banned by multiple residents
SELECT 
    phone,
    name,
    COUNT(*) as ban_count,
    ARRAY_AGG(DISTINCT u.apartment_number) as banned_by_apartments,
    MAX(vb.severity) as highest_severity
FROM visitor_bans vb
JOIN users u ON vb.user_id = u.id
WHERE vb.building_id = ? AND vb.is_active = true
GROUP BY phone, name
HAVING COUNT(*) > 1
ORDER BY ban_count DESC;
```

#### Automated Ban Management
```sql
-- Run automatic ban expiry (for scheduled jobs)
SELECT expire_visitor_bans();

-- Check for expiring bans (within next 24 hours)
SELECT 
    name,
    phone,
    expires_at,
    CONCAT(u.first_name, ' ', u.last_name) as banned_by
FROM visitor_bans vb
JOIN users u ON vb.user_id = u.id
WHERE vb.is_active = true
AND vb.expires_at IS NOT NULL
AND vb.expires_at <= CURRENT_TIMESTAMP + INTERVAL '24 hours'
ORDER BY expires_at;
```

### Analytics Queries
```sql
-- Building dashboard data
SELECT 
    bs.*,
    va.total_visits as visits_today,
    sm.active_emergencies,
    bbs.total_bans,
    bbs.active_bans
FROM building_stats bs
LEFT JOIN visit_analytics va ON bs.building_id = va.building_id 
    AND va.visit_date = CURRENT_DATE
LEFT JOIN security_monitoring sm ON bs.building_id = sm.building_id
LEFT JOIN building_ban_stats bbs ON bs.building_id = bbs.building_id
WHERE bs.building_id = ?;

-- User activity summary with ban information
SELECT 
    uad.*,
    ubs.total_bans_created,
    ubs.active_bans,
    ubs.unique_visitors_banned
FROM user_activity_dashboard uad
LEFT JOIN user_ban_stats ubs ON uad.user_id = ubs.user_id
WHERE uad.building_id = ? 
ORDER BY uad.visits_this_week DESC;

-- Visit trends with ban correlation
SELECT 
    visit_date,
    total_visits,
    total_visitors,
    avg_visitors_per_visit,
    completed_visits::float / total_visits * 100 as completion_rate,
    COALESCE(ban_counts.daily_bans, 0) as bans_created
FROM visit_analytics va
LEFT JOIN (
    SELECT DATE(banned_at) as ban_date, COUNT(*) as daily_bans
    FROM visitor_bans 
    WHERE building_id = ? 
    GROUP BY DATE(banned_at)
) ban_counts ON va.visit_date = ban_counts.ban_date
WHERE va.building_id = ? 
AND va.visit_date >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY visit_date;
```

---

## üîß Maintenance

### Daily Maintenance
```sql
-- Run via cron job daily
SELECT * FROM daily_maintenance();

-- Tasks performed:
-- 1. Cleanup expired sessions and old notifications
-- 2. Archive old visits (>1 year)
-- 3. Refresh materialized views
-- 4. Update frequent visitor status
-- 5. Mark expired visits
```

### Manual Maintenance Tasks

#### Weekly License Review
```sql
-- Check license utilization across buildings
SELECT * FROM get_license_utilization() 
WHERE utilization_percentage > 80;
```

#### Monthly Performance Review
```sql
-- Table size analysis
SELECT * FROM get_table_stats() 
ORDER BY pg_total_relation_size DESC;

-- Slow query analysis (requires pg_stat_statements)
SELECT * FROM get_slow_queries('5 seconds'::interval);
```

#### Data Archival
```sql
-- Archive old completed visits
SELECT archive_old_visits(); 

-- Bulk update expired visits
SELECT bulk_update_visit_status(
    building_uuid,
    'pending'::visit_status,
    'expired'::visit_status,
    CURRENT_TIMESTAMP - INTERVAL '48 hours'
);
```

### Monitoring Recommendations

#### Health Checks
```sql
-- Monitor critical metrics
SELECT 
    COUNT(*) as active_visits,
    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as visits_today
FROM visits 
WHERE status = 'active' AND building_id = ?;

-- License usage alerts
SELECT building_name, utilization_percentage 
FROM get_license_utilization() 
WHERE utilization_percentage > 90;
```

#### Performance Monitoring
- Monitor `visit_logs` growth rate
- Track QR scan response times
- Monitor materialized view refresh duration
- Alert on failed daily maintenance runs

---

## üóÑÔ∏è Database Reset and Constraint Management

### Database Reset Process

When you need to completely reset the SafeGuard database (for development or troubleshooting), follow this comprehensive process that handles foreign key constraints and triggers properly.

#### Understanding the Challenge

The SafeGuard database has complex relationships with:
- **48 foreign key constraints** maintaining data integrity
- **Audit triggers** that log all changes to critical tables
- **Analytical triggers** collecting real-time metrics
- **Business logic triggers** managing license counts and visit completion

Simply deleting data can cause **foreign key constraint violations** because:
1. Audit triggers try to log deletions while referencing being-deleted records
2. CASCADE operations may not reach all dependent records
3. Trigger execution order can create circular dependencies

#### The Force Reset Solution

The database reset process uses a **multi-step approach** to safely clear all data:

```sql
-- 1. DROP ALL TRIGGERS
-- Remove all triggers to prevent constraint violations during deletion
SELECT trigger_name, event_object_table 
FROM information_schema.triggers 
WHERE trigger_schema = 'public';

-- Drop each trigger:
DROP TRIGGER IF EXISTS trigger_name ON table_name CASCADE;

-- 2. DISABLE FOREIGN KEY CONSTRAINTS
-- Temporarily disable constraint checking
SET session_replication_role = replica;

-- 3. TRUNCATE WITH CASCADE
-- Force clear all data ignoring foreign keys
TRUNCATE TABLE table_name RESTART IDENTITY CASCADE;

-- 4. RE-ENABLE CONSTRAINTS
-- Restore normal constraint checking
SET session_replication_role = DEFAULT;

-- 5. RECREATE ESSENTIAL TRIGGERS
-- Restore only the critical audit trigger with safety checks
CREATE OR REPLACE FUNCTION create_audit_log() RETURNS TRIGGER AS $$
DECLARE
    user_id UUID;
    building_id UUID;
    visit_id UUID;
    action TEXT;
BEGIN
    -- Only create audit log if user exists
    IF TG_OP = 'DELETE' THEN
        user_id := OLD.user_id;
        building_id := OLD.building_id;
        visit_id := OLD.visit_id;
        action := 'DELETE';
        
        -- Check if user exists before creating audit log
        IF EXISTS (SELECT 1 FROM users WHERE id = user_id) THEN
            INSERT INTO audit_logs (user_id, building_id, visit_id, action, resource_type, resource_id, old_values)
            VALUES (user_id, building_id, visit_id, action, TG_TABLE_NAME, OLD.id, row_to_json(OLD));
        END IF;
        
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

#### Current Database State After Reset

After a successful force reset, the database has:

‚úÖ **Foreign Key Constraints**: **48 active constraints** maintaining data integrity
```sql
-- Major constraint relationships:
users.building_id ‚Üí buildings.id
visits.host_id ‚Üí users.id
visitors.created_by ‚Üí users.id
visit_visitors.visit_id ‚Üí visits.id
visitor_bans.user_id ‚Üí users.id
audit_logs.user_id ‚Üí users.id
-- ... and 42 more
```

‚úÖ **Clean Tables**: All data tables have **0 records**
- 0 users (including super admins)
- 0 buildings
- 0 visitors, visits, licenses
- 0 audit logs, notifications

‚ùå **No Active Triggers**: **0 triggers** currently attached (prevents constraint conflicts)
- Triggers are NOT automatically recreated
- Only the `create_audit_log()` function exists
- This is intentional to prevent future constraint issues

‚úÖ **Available Trigger Functions**: **16 trigger functions** ready for use
- `create_audit_log()` - Safe audit logging
- License management functions
- Analytics collection functions
- Timestamp update functions

### Constraint Management Best Practices

#### 1. **Understanding CASCADE Behavior**
```sql
-- CASCADE operations propagate through foreign key relationships
DELETE FROM buildings CASCADE;
-- This would delete:
-- - All users in the building
-- - All visits hosted by those users  
-- - All visitors created by those users
-- - All related audit logs, notifications, etc.
```

#### 2. **Safe Constraint Disabling**
```sql
-- Temporary constraint disabling (use with extreme caution)
SET session_replication_role = replica;  -- Disables triggers and FKs
-- Perform bulk operations
SET session_replication_role = DEFAULT;  -- Re-enables constraints
```

#### 3. **Checking Constraint Status**
```sql
-- List all foreign key constraints
SELECT 
    tc.constraint_name,
    tc.table_name,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_schema = 'public'
ORDER BY tc.table_name;
```

#### 4. **Monitoring Constraint Violations**
Look for these common error patterns:
```sql
-- Foreign key constraint violation
ERROR: insert or update on table "table_name" violates foreign key constraint
Detail: Key (column_name)=(value) is not present in table "referenced_table"

-- Circular dependency in CASCADE
ERROR: cannot delete from table because other objects depend on it
Detail: constraint xyz on table abc depends on table def
```

### Trigger Management

#### Current Trigger State
After database reset:
- **All triggers removed** to prevent constraint conflicts
- **Trigger functions preserved** and ready for reattachment
- **create_audit_log()** function enhanced with safety checks

#### Trigger Recreation Strategy
You can selectively recreate triggers based on your needs:

```sql
-- 1. Critical Audit Triggers (recommended)
CREATE TRIGGER tr_users_audit
    BEFORE DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION create_audit_log();

-- 2. License Management (for production)
CREATE TRIGGER tr_user_license_count
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION update_building_license_count();

-- 3. Analytics Collection (optional)
CREATE TRIGGER tr_visits_analytics
    AFTER INSERT OR UPDATE ON visits
    FOR EACH ROW EXECUTE FUNCTION create_analytics_event();
```

#### Trigger Safety Patterns
All new triggers should follow this safety pattern:
```sql
CREATE OR REPLACE FUNCTION safe_trigger_function() RETURNS TRIGGER AS $$
BEGIN
    -- Always check if referenced records exist
    IF TG_OP = 'DELETE' THEN
        -- Verify parent records exist before logging
        IF EXISTS (SELECT 1 FROM parent_table WHERE id = OLD.parent_id) THEN
            -- Safe to proceed with trigger logic
            INSERT INTO audit_logs (...);
        END IF;
        RETURN OLD;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### Database Recovery Procedures

#### Full System Recovery
```sql
-- 1. Database reset (clears all data)
-- Run force reset script

-- 2. Initial system setup
POST /api/admin/initial-setup
{
  "email": "superadmin@metroplex.com",
  "password": "SuperSecure2024!",
  "firstName": "Sarah",
  "lastName": "Johnson",
  "buildingData": {
    "name": "Metroplex Towers",
    "address": "123 Business District",
    "city": "Lagos"
  }
}

-- 3. Verify system state
SELECT COUNT(*) FROM users;      -- Should be 1 (super admin)
SELECT COUNT(*) FROM buildings;  -- Should be 1 (initial building)
SELECT COUNT(*) FROM licenses;   -- Should be 1 (building license)
```

#### Partial Recovery (Development)
```sql
-- Clear specific data while preserving structure
DELETE FROM visit_logs;
DELETE FROM notifications;
DELETE FROM visits;
DELETE FROM visitors;
-- Keep users and buildings for testing
```

### Important Notes

‚ö†Ô∏è **Production Warnings**:
- Never disable constraints in production without proper backup
- Always test recovery procedures in development first
- Monitor constraint violations in application logs

‚úÖ **Development Benefits**:
- Clean slate for testing new features
- Consistent database state across team members
- Easy troubleshooting of schema issues

üí° **Next Steps After Reset**:
1. Use `/api/admin/initial-setup` to create first super admin and building
2. Test with updated Postman collections using new test data
3. Recreate any custom triggers needed for development
4. Verify all foreign key relationships are working correctly

---

## üöÄ Getting Started

### For New Developers

1. **Understand the Core Flow**:
   ```
   User creates visit ‚Üí QR generated ‚Üí Visitors scan QR ‚Üí Individual tracking ‚Üí Visit completion
   ```

2. **Key Tables to Focus On**:
   - `visits` (core entity)
   - `visitors` (reusable profiles)
   - `visit_visitors` (many-to-many relationship)

3. **Essential Functions**:
   - `create_visit_with_visitors()` - Visit creation
   - `process_qr_scan()` - Gate operations
   - `update_visit_visitor_status()` - Visitor tracking

4. **Common Queries**:
   - Use views for dashboard data
   - Use functions for business logic
   - Check RLS policies for data access

### Migration from Old System
If migrating from a visitor-centric system:
1. Export existing visitor data
2. Group visitors by time/host into visits
3. Generate visit records with associated visitors
4. Preserve visitor history and ratings

---

## üìö Additional Resources

- **API Documentation**: See `/docs/api/` for REST and Socket endpoints
- **Business Logic**: Application layer handles QR generation and validation
- **Security**: See audit logs for all database changes
- **Performance**: Monitor slow queries and table growth
- **Backup**: Daily backups recommended with point-in-time recovery

---

## üìù Migration History

### Migration: Enhanced Login Tracking (2025-01-06)
**Migration ID**: `2025_01_06_001_enhanced_login_tracking`  
**File**: `migrations/add_enhanced_login_tracking.sql`  
**Status**: ‚úÖ Completed Successfully

#### Summary
Added enhanced authentication tracking capabilities to the users table to support advanced security features and analytics.

#### Changes Made
1. **Added Columns**:
   - `last_login_ip (INET)`: Tracks the IP address from the user's most recent successful login
   - `last_user_agent (TEXT)`: Stores the user agent string from the user's most recent successful login

2. **Performance Optimizations**:
   - Added `idx_users_last_login_ip` index on `last_login_ip` (partial index for non-NULL values)
   - Added `idx_users_last_login` index on `last_login` (partial index for non-NULL values)

3. **Documentation**:
   - Added column comments explaining the purpose of each new field
   - Updated existing records to have NULL values explicitly

#### Impact
- **Enhanced Security**: System can now track login locations and detect suspicious access patterns
- **Improved Analytics**: Device and location-based user behavior analysis
- **Better User Experience**: Foundation for features like "New device detected" notifications
- **Performance**: Strategic indexing ensures fast lookups for security checks

#### Database Schema Changes
```sql
-- Before Migration
users table: 20 columns (id through updated_at)

-- After Migration  
users table: 22 columns (added last_login_ip, last_user_agent)
```

#### Migration Execution Details
- **Execution Date**: 2025-01-06
- **Execution Time**: < 1 second (2 existing records updated)
- **Rollback Available**: Standard column drop procedures
- **Data Loss**: None (all operations are additive)

#### Supporting Features
This migration enables the enhanced authentication controller consolidation, which includes:
- Risk-based authentication
- Device fingerprinting
- Location-based access controls
- Suspicious activity detection
- Session management improvements

### Migration: Fix Login Tracking Columns (2025-01-06) 
**Migration ID**: `2025_01_06_002_fix_login_tracking_columns`  
**File**: `migrations/fix_login_tracking_columns.sql`  
**Status**: ‚úÖ Completed Successfully

#### Summary
Fixed database connection issue and ensured login tracking columns are properly created.

#### Issue Resolved
- **Problem**: Application error "column 'last_login_ip' of relation 'users' does not exist"  
- **Root Cause**: URL encoding issue with `@` character in database password
- **Solution**: URL-encoded password (`%40`) and re-ran migration

#### Changes Made
1. **Fixed DATABASE_URL**: Properly encoded password with `%40` instead of `@`
2. **Verified Columns**: Confirmed both columns exist with proper indexing
3. **Added Safety Checks**: Migration includes verification that columns were created

#### Database Connection Fix
```bash
# Before (broken):
DATABASE_URL='postgresql://user:pass@word@host:5432/db'

# After (working): 
DATABASE_URL='postgresql://user:pass%40word@host:5432/db'
```

#### Future Migrations Planned
- Enhanced session tracking with device fingerprints
- Location-based security policies  
- Multi-factor authentication support

### Migration: Resident Approval System (2025-01-08)
**Migration ID**: `2025_01_08_001_resident_approval_system`  
**File**: `migrations/create_resident_approval_requests.sql`  
**Status**: ‚úÖ Completed Successfully

#### Summary
Implemented comprehensive resident approval workflow system that requires building admin approval for new resident registrations.

#### Changes Made
1. **Added Table**: `resident_approval_requests`
   - Complete approval workflow with 13 columns
   - Automatic expiry after 30 days
   - Building-specific access control
   - Comprehensive audit trail
   
2. **Performance Optimizations**:
   - `idx_resident_approval_building_status` index for admin queries
   - `idx_resident_approval_user` index for user lookup
   - `idx_resident_approval_expires` index for expiry processing
   - `idx_resident_approval_created` index for chronological sorting

3. **Business Logic Integration**:
   - Updated user registration to create is_active=false users
   - Approval process activates user accounts
   - Complete integration with existing authentication system

#### Impact
- **Enhanced Security**: All new residents require admin approval before system access
- **Improved Management**: Building admins control resident onboarding
- **Complete Audit Trail**: Full tracking of approval decisions and reasons
- **Scalable Architecture**: Supports multiple buildings with isolated approval queues

#### Database Schema Changes
```sql
-- Before Migration
- 9 core tables (users, buildings, visitors, etc.)

-- After Migration  
- 10 core tables (added resident_approval_requests)
- 4 new indexes for optimal performance
- 2 new constraints for data integrity
```

#### API Integration
- **New Endpoints**: 7 resident approval API endpoints
- **Authentication**: Building-specific access control
- **Real-time Updates**: Socket.io integration for approval notifications
- **Postman Testing**: Comprehensive test collections updated

#### Migration Execution Details
- **Execution Date**: 2025-01-08
- **Execution Time**: < 1 second (clean database)
- **Rollback Available**: Standard table drop procedures
- **Data Loss**: None (all operations are additive)

#### Supporting Features
This migration enables:
- Self-service resident registration
- Building admin approval dashboard
- Automated approval request expiry
- Email notifications for approval decisions
- Complete integration with existing user management

### Migration: QR Code Entry/Exit Tracking - Version 2 (2025-01-14)
**Migration ID**: `2025_01_14_001_qr_entry_exit_tracking`  
**File**: `migrations/006_add_entry_exit_columns.sql`  
**Status**: ‚úÖ Completed Successfully

#### Summary
Implemented Version 2 QR code scanning functionality that tracks building entry and exit separately, providing granular visitor access control and enhanced security monitoring.

#### Changes Made
1. **Added Columns to `visits` Table**:
   - `entry (BOOLEAN)`: Tracks if visitor has scanned QR code at building entry (DEFAULT: FALSE)
   - `exit (BOOLEAN)`: Tracks if visitor has scanned QR code at building exit (DEFAULT: FALSE)

2. **Performance Optimizations**:
   - `idx_visits_entry` index for entry status queries
   - `idx_visits_exit` index for exit status queries
   - `idx_visits_entry_exit` composite index for entry/exit status combinations

3. **New Database Function**: `process_qr_entry_exit_scan()`
   ```sql
   SELECT * FROM process_qr_entry_exit_scan(
       p_qr_code TEXT,
       p_scan_type VARCHAR(10), -- 'entry' or 'exit'
       p_security_officer UUID,
       p_gate_number VARCHAR(20) DEFAULT NULL,
       p_location POINT DEFAULT NULL
   );
   ```

4. **Business Logic Enhancements**:
   - **Entry Scanning**: Sets `entry = TRUE`, updates visit status to 'active'
   - **Exit Scanning**: Sets `exit = TRUE`, updates visit status to 'completed'
   - **Validation**: Cannot exit without entry scan first
   - **Prevents Duplicate Scans**: Checks existing entry/exit status
   - **Real-time Notifications**: Sends appropriate notifications for entry/exit

#### Impact
- **Enhanced Security**: Separate tracking of building entry and exit points
- **Granular Control**: Security can control both entry and exit processes independently
- **Audit Trail**: Complete tracking of visitor movement through building access points
- **Compliance**: Meets security requirements for visitor access monitoring

#### API Integration
- **New Endpoints**: 
  - `POST /api/visitors/scan/entry` - Scan QR for building entry (security only)
  - `POST /api/visitors/scan/exit` - Scan QR for building exit (security only)
- **Role-Based Access**: Only users with 'security' role can scan QR codes
- **Enhanced Middleware**: New `requireSecurityOnly` middleware for strict role enforcement

#### Database Schema Changes
```sql
-- Before Migration
visits table: 28 columns (id through updated_at)

-- After Migration  
visits table: 30 columns (added entry, exit)
- entry (BOOLEAN DEFAULT FALSE)
- exit (BOOLEAN DEFAULT FALSE)
- 3 new indexes for performance optimization
```

#### Security Enhancements
1. **Strict Role Enforcement**: Only security personnel can scan QR codes
2. **Sequential Validation**: Must scan entry before exit
3. **Duplicate Prevention**: Cannot scan same QR multiple times for same action
4. **Complete Audit Trail**: All scans logged with timestamp, officer, and location

#### Migration Execution Details
- **Execution Date**: 2025-01-14
- **Execution Time**: < 1 second (schema changes only)
- **Rollback Available**: Column drop procedures available
- **Data Loss**: None (all operations are additive)
- **Existing Data**: All existing visits default to entry=false, exit=false

#### Supporting Features
This migration enables:
- Separate entry/exit gate scanning
- Enhanced visitor flow tracking
- Security checkpoint management
- Building access compliance
- Real-time visitor location awareness within building
- Advanced analytics on visitor entry/exit patterns

#### Function Details
The new `process_qr_entry_exit_scan()` function provides:
- **Validation**: QR code format and expiry checking
- **Status Management**: Automatic visit status transitions
- **Logging**: Comprehensive action logging with security officer details
- **Notifications**: Real-time alerts to hosts about visitor entry/exit
- **Error Handling**: Detailed error messages for invalid operations

#### Usage Example
```sql
-- Entry scan
SELECT * FROM process_qr_entry_exit_scan(
    'SG_ABC123DEF456', 
    'entry', 
    '550e8400-e29b-41d4-a716-446655440000',
    'Main Gate',
    POINT(-6.5244, 3.3792)
);

-- Exit scan  
SELECT * FROM process_qr_entry_exit_scan(
    'SG_ABC123DEF456',
    'exit',
    '550e8400-e29b-41d4-a716-446655440000', 
    'Main Gate',
    POINT(-6.5244, 3.3792)
);
```

This migration represents a significant enhancement to the SafeGuard system's access control capabilities, providing building administrators and security personnel with granular control over visitor movement tracking.

---

This database schema provides a robust foundation for the SafeGuard visitor management system, with unlimited scalability for visitors while maintaining license control for registered users.
