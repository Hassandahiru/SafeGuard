# SafeGuard Database Documentation

## 📋 Table of Contents
- [Overview](#overview)
- [Architecture](#architecture)
- [Core Tables](#core-tables)
- [Relationships](#relationships)
- [Functions](#functions)
- [Triggers](#triggers)
- [Views](#views)
- [Security](#security)
- [Performance](#performance)
- [Usage Examples](#usage-examples)
- [Maintenance](#maintenance)

---

## 🏗️ Overview

The SafeGuard database implements a **visit-centric visitor management system** for gated communities and residential buildings. The core philosophy is that **visits (not individual visitors) receive QR codes**, and multiple visitors can be associated with a single visit.

### Key Concepts
- **Buildings** have 250 licenses by default (for registered users, not visitors)
- **Users** can create unlimited visitors per month
- **Visits** are the primary entity that gets QR codes
- **Visitors** are reusable profiles stored per building
- **QR codes** contain visit information and are generated by business logic after visit creation

---

## 🏛️ Architecture

### Database Design Principles
1. **Visit-Centric**: Everything revolves around visits, not individual visitors
2. **Reusable Profiles**: Visitor profiles can be reused across multiple visits
3. **License Management**: Only registered users count against building licenses
4. **Security-First**: Comprehensive audit trails and multi-level access control
5. **Performance-Optimized**: Strategic indexing and materialized views
6. **Schema Separation**: Logical organization with dedicated schemas for different domains
7. **Profile Management**: Extended user profiles with approval workflows

### Technology Stack
- **Database**: PostgreSQL 12+
- **Extensions**: uuid-ossp, postgis (optional for location features)
- **Features**: Row Level Security, Triggers, Materialized Views, Custom Types
- **Schema Organization**: Multi-schema architecture for better maintainability

### Schema Organization (Planned v2.0)
```
safeguard_db
├── public                    # Core system tables
├── profile_management        # User profiles and registration workflows
├── building_management       # Buildings, licenses, and admin operations
└── visitor_management        # Visitor and visit management
```

---

## 📊 Core Tables

### 1. Buildings (`buildings`)
**Purpose**: Represents physical buildings/estates in the system

```sql
Key Fields:
- id (UUID, PK): Unique building identifier
- name, address, city, state, country: Building details
- total_licenses (INT): Total user licenses (default: 250)
- used_licenses (INT): Currently used licenses (auto-calculated)
- location (POINT): GPS coordinates for geofencing
- is_active (BOOLEAN): Building status
```

**Business Rules**:
- Each building gets 250 licenses by default
- Only active registered users count against licenses
- Visitors don't consume licenses

### 2. Users (`users`)
**Purpose**: Registered users in the system (residents, admins, security)

```sql
Key Fields:
- id (UUID, PK): Unique user identifier
- building_id (UUID, FK): Reference to building
- email (VARCHAR, UNIQUE): Login email
- role (user_role): 'super_admin', 'building_admin', 'resident', 'security', 'visitor'
- uses_license (BOOLEAN): Whether user counts against building licenses
- apartment_number (VARCHAR): Resident's apartment
- is_active (BOOLEAN): User status
```

**Business Rules**:
- Residents and admins use licenses by default
- Security and temporary users may not use licenses
- Email must be unique across the entire system

### 3. Visitors (`visitors`)
**Purpose**: Reusable visitor profiles per building

```sql
Key Fields:
- id (UUID, PK): Unique visitor identifier
- building_id (UUID, FK): Reference to building
- created_by (UUID, FK): User who first registered this visitor
- name, phone, email: Visitor contact details
- is_frequent (BOOLEAN): Auto-updated based on visit history
- visit_count (INT): Total number of visits
- rating (DECIMAL): Average rating from hosts
```

**Business Rules**:
- One visitor profile per phone number per building
- Profiles are reusable across multiple visits
- Automatically marked as frequent if visit_count >= 5

### 4. Visits (`visits`) 🎯 **CORE TABLE**
**Purpose**: The primary entity that receives QR codes and manages visitor access

```sql
Key Fields:
- id (UUID, PK): Unique visit identifier
- building_id (UUID, FK): Reference to building
- host_id (UUID, FK): User hosting the visit
- title (VARCHAR): Visit description ("Business Meeting", "Birthday Party")
- visit_type (visit_type): 'single', 'group', 'recurring'
- qr_code (TEXT, UNIQUE): Generated QR code string
- qr_code_data (JSONB): Encrypted visit details for QR
- status (visit_status): 'pending', 'confirmed', 'active', 'completed', 'cancelled', 'expired'
- expected_start/end (TIMESTAMPTZ): Planned visit times
- current_visitors (INT): Number of visitors added to this visit
- max_visitors (INT): Maximum allowed visitors
```

**Business Rules**:
- QR codes are generated AFTER visit creation by business logic
- One QR code per visit, regardless of visitor count
- Status automatically transitions based on visitor actions

### 5. Visit Visitors (`visit_visitors`)
**Purpose**: Junction table linking visits to multiple visitors

```sql
Key Fields:
- visit_id (UUID, FK): Reference to visit
- visitor_id (UUID, FK): Reference to visitor
- status (VARCHAR): 'expected', 'arrived', 'entered', 'exited'
- arrival_time, departure_time (TIMESTAMPTZ): Actual times
- added_by (UUID, FK): User who added this visitor to the visit
```

**Business Rules**:
- Multiple visitors can be added to one visit
- Each visitor has individual status tracking within the visit
- Automatic triggers update visit completion status

### 6. Frequent Visitors (`frequent_visitors`)
**Purpose**: User's personal favorites list for quick access

```sql
Key Fields:
- user_id (UUID, FK): Reference to user
- visitor_id (UUID, FK): Reference to visitor
- nickname (VARCHAR): Custom name for this relationship
- relationship (VARCHAR): 'family', 'friend', 'colleague', 'service_provider'
- priority (INT): 1-5 priority ranking (1 = highest)
```

### 7. Visitor Bans (`visitor_bans`) 🚫 **PHONE-CENTRIC BAN SYSTEM**
**Purpose**: Advanced phone-centric visitor restriction system with personal blacklists

```sql
Key Fields:
- id (UUID, PK): Unique ban identifier
- building_id (UUID, FK): Reference to building  
- user_id (UUID, FK): User who created the ban
- name (VARCHAR): Visitor's name (stored directly)
- phone (VARCHAR): Visitor's phone number (primary identifier)
- reason (TEXT): Why visitor was banned
- severity (ban_severity): 'low', 'medium', 'high' - escalation levels
- ban_type (ban_type): 'manual' (user-created) or 'automatic' (system-generated)
- is_active (BOOLEAN): Current ban status
- banned_at (TIMESTAMPTZ): When ban was created
- expires_at (TIMESTAMPTZ): When ban expires (NULL for permanent)
- unbanned_at (TIMESTAMPTZ): When ban was lifted
- unban_reason (TEXT): Why ban was removed
- unbanned_by (UUID, FK): Who removed the ban
- notes (TEXT): Additional context
- trigger_event (VARCHAR): For automatic bans - what triggered it
- metadata (JSONB): Extensible data storage
```

**Business Rules**:
- **Phone-Centric**: Bans target phone numbers directly, not visitor profiles
- **Personal Blacklists**: Each resident maintains their own ban list
- **Building-wide Visibility**: Residents can see if others have banned the same visitor
- **Severity Escalation**: low → medium → high based on incidents
- **Temporary Bans**: Automatic expiry with `expires_at` field
- **Complete Audit Trail**: Full tracking of ban creation, updates, and removal
- **Flexible Storage**: Direct phone/name storage eliminates visitor profile dependencies

**Key Features**:
1. **Individual Control**: Residents can ban visitors independently
2. **Cross-resident Awareness**: Check if visitor is banned by others in building
3. **Automatic Expiry**: Temporary bans with configurable duration
4. **Severity Levels**: Escalating restriction levels (low/medium/high)
5. **Unban Tracking**: Complete audit trail for ban removal
6. **Performance Optimized**: Direct phone lookups without JOINs

### 8. System Blacklist (`system_blacklist`)
**Purpose**: Building-wide restrictions managed by admins and security

**System Bans**:
- Building-wide restrictions
- Managed by admins and security
- Affects all residents in the building

### 8. Visit Logs (`visit_logs`)
**Purpose**: Detailed tracking of all visitor actions

```sql
Key Fields:
- visit_id (UUID, FK): Reference to visit
- visitor_id (UUID, FK): Reference to visitor (nullable for visit-level actions)
- action (VARCHAR): 'qr_scanned', 'arrived', 'entered', 'exited', 'departed'
- timestamp (TIMESTAMPTZ): When action occurred
- security_officer (UUID, FK): Officer who processed the action
- gate_number (VARCHAR): Which gate was used
```

### 9. Notifications (`notifications`)
**Purpose**: Real-time messaging system

```sql
Key Fields:
- user_id (UUID, FK): Recipient
- visit_id (UUID, FK): Related visit (nullable)
- visitor_id (UUID, FK): Related visitor (nullable)
- type (notification_type): 'visit_created', 'visitor_arrival', 'emergency', etc.
- is_read (BOOLEAN): Read status
- priority (INT): 1-5 priority level
```

### 10. Profile Management System (Planned v2.0)

#### Extended User Profiles (`profile_management.user_profiles`)
**Purpose**: Enhanced user profile data beyond basic account information

```sql
Key Fields:
- user_id (UUID, FK): Reference to core user account
- avatar_url (TEXT): Profile picture URL
- bio (TEXT): User biography (max 500 chars)
- date_of_birth (DATE): For age verification
- emergency_contact (JSONB): Emergency contact information
- notification_preferences (JSONB): Email, push, alert preferences
- privacy_settings (JSONB): Visibility and sharing controls
- theme_preferences (JSONB): UI theme and language settings
```

#### Pending Registrations (`profile_management.pending_registrations`)
**Purpose**: Registration approval workflow system

```sql
Key Fields:
- email, password_hash, personal_info: Registration data
- building_email (VARCHAR): Building admin contact email
- status (ENUM): 'pending', 'approved', 'rejected', 'expired'
- verification_token (VARCHAR): Email verification token
- expires_at (TIMESTAMPTZ): Auto-expiry after 7 days
- approved_by (UUID, FK): Which admin processed the request
- rejection_reason (TEXT): Admin feedback for rejections
```

**Business Rules**:
- Users submit registration with building email
- Building admins receive notification to approve/reject
- Auto-expires after 7 days if no action taken
- Complete audit trail of approval process

#### License Allocations (`building_management.license_allocations`)
**Purpose**: Track license assignments by building admins

```sql
Key Fields:
- building_id, user_id: License assignment
- allocated_by (UUID, FK): Admin who assigned license
- allocation_method (ENUM): 'admin', 'auto', 'system'
- expires_at (TIMESTAMPTZ): License expiry date
- is_active (BOOLEAN): Current license status
```

### 11. Supporting Tables
- **`licenses`**: Building subscription management
- **`payments`**: Payment processing tracking
- **`emergency_alerts`**: Security incident management
- **`audit_logs`**: Comprehensive security audit trail
- **`user_sessions`**: JWT token management
- **`analytics_events`**: Real-time analytics data collection

---

## 🔗 Relationships

### Primary Relationships
```
buildings (1) ← (M) users
buildings (1) ← (M) visitors
buildings (1) ← (M) visits
users (1) ← (M) visits (as host)
users (1) ← (M) visitors (as creator)
visits (M) ← (M) visitors (via visit_visitors)
users (1) ← (M) frequent_visitors
```

### Key Foreign Key Constraints
- All major tables reference `buildings` for data isolation
- `visits.host_id` → `users.id` (who's hosting)
- `visitors.created_by` → `users.id` (who registered the visitor)
- `visit_visitors` creates M:M between visits and visitors

---

## ⚙️ Functions

### Core Business Logic Functions

#### 1. `create_visit_with_visitors()`
**Purpose**: Creates a visit and adds multiple visitors in a transaction

```sql
SELECT * FROM create_visit_with_visitors(
    p_building_id UUID,
    p_host_id UUID,
    p_title VARCHAR(255),
    p_description TEXT,
    p_expected_start TIMESTAMP WITH TIME ZONE,
    p_expected_end TIMESTAMP WITH TIME ZONE,
    p_visitors JSONB, -- Array of visitor objects
    p_visit_type visit_type DEFAULT 'single'
);

-- Returns: success, visit_id, qr_code, message, visitor_count
```

**What it does**:
1. Checks building license availability
2. Creates a new visit record
3. Generates QR code data (encrypted visit details)
4. Processes visitor array (creates new or uses existing profiles)
5. Checks ban status for each visitor
6. Links visitors to visit via `visit_visitors`
7. Returns complete visit information

#### 2. `process_qr_scan()`
**Purpose**: Handles QR code scanning at building gates

```sql
SELECT * FROM process_qr_scan(
    p_qr_code TEXT,
    p_gate_number VARCHAR(20) DEFAULT NULL,
    p_security_officer UUID DEFAULT NULL,
    p_location POINT DEFAULT NULL
);

-- Returns: success, message, visit_data, visitors (array)
```

**What it does**:
1. Validates QR code and expiration
2. Retrieves visit and all associated visitors
3. Updates visit status to 'active' if first scan
4. Logs the QR scan action
5. Creates notification for host
6. Returns complete visit and visitor information

#### 3. `update_visit_visitor_status()`
**Purpose**: Updates individual visitor status within a visit

```sql
SELECT * FROM update_visit_visitor_status(
    p_visit_id UUID,
    p_visitor_id UUID,
    p_new_status VARCHAR(50), -- 'arrived', 'entered', 'exited'
    p_security_officer UUID DEFAULT NULL,
    p_location POINT DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
);
```

**What it does**:
1. Validates status transition
2. Updates visitor status in `visit_visitors`
3. Sets timestamps (arrival_time, departure_time)
4. Logs the action in `visit_logs`
5. Updates visitor's total visit count if entering

#### 4. `get_or_create_visitor()`
**Purpose**: Finds existing visitor or creates new profile

```sql
SELECT get_or_create_visitor(
    p_building_id UUID,
    p_created_by UUID,
    p_name VARCHAR(255),
    p_phone VARCHAR(20),
    p_email VARCHAR(255) DEFAULT NULL
) RETURNS UUID;
```

**What it does**:
1. Searches for existing visitor by building + phone
2. If found, updates information and returns ID
3. If not found, creates new visitor profile
4. Enforces unique constraint per building

#### 5. Phone-Centric Ban Checking Functions 🚫
**Purpose**: Advanced ban checking for phone-centric visitor restriction system

##### `is_visitor_banned_by_phone()`
```sql
SELECT is_visitor_banned_by_phone(
    p_building_id UUID,
    p_user_id UUID,
    p_phone VARCHAR(20)
) RETURNS BOOLEAN;
```

**What it does**:
1. Formats phone number for consistency
2. Checks personal bans (`visitor_bans`) by phone
3. Checks system-wide bans (`system_blacklist`) by phone  
4. Considers ban expiration dates and active status
5. Returns true if visitor is banned at any level

##### `is_visitor_banned_by_user()`
```sql
SELECT is_visitor_banned_by_user(
    p_user_id UUID,
    p_phone TEXT
) RETURNS BOOLEAN;
```

**What it does**:
1. Checks if specific user has banned this phone number
2. Considers only active bans with valid expiration
3. Used for personal blacklist checking

##### `is_visitor_banned_in_building()`
```sql
SELECT is_visitor_banned_in_building(
    p_building_id UUID,
    p_phone TEXT
) RETURNS BOOLEAN;
```

**What it does**:
1. Checks if any resident in building has banned this phone number
2. Returns true if visitor is banned by anyone in the building
3. Used for building-wide ban visibility

##### `format_phone_number()`
```sql
SELECT format_phone_number(phone_input TEXT) RETURNS TEXT;
```

**What it does**:
1. Standardizes phone number format for consistency
2. Adds +234 prefix for Nigerian numbers
3. Removes non-digit characters except +
4. Ensures uniform storage and comparison

##### `expire_visitor_bans()`
```sql
SELECT expire_visitor_bans() RETURNS INTEGER;
```

**What it does**:
1. Automatically expires temporary bans past their expiry date
2. Sets `is_active = false` and records unban details
3. Returns count of expired bans
4. Intended for automated/scheduled execution

### Analytics Functions

#### 6. `get_building_analytics()`
**Purpose**: Comprehensive building statistics

```sql
SELECT * FROM get_building_analytics(
    p_building_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE,
    p_end_date TIMESTAMP WITH TIME ZONE
);

-- Returns: total_visits, total_visitors, avg_visit_duration, 
--          peak_hour, most_active_host, visit_completion_rate
```

#### 7. `get_visitor_recommendations()`
**Purpose**: AI-powered visitor suggestions

```sql
SELECT * FROM get_visitor_recommendations(
    p_user_id UUID,
    p_limit INTEGER DEFAULT 10
);
```

**Scoring Algorithm**:
- Frequent status: +100 points
- Recent visits (30 days): +50 points
- Recent visits (90 days): +25 points
- Each visit: +5 points
- Rating: +(rating * 10) points

### Utility Functions

#### 8. `generate_qr_code_data()`
**Purpose**: Creates QR code payload with visit details

#### 9. `check_license_availability()`
**Purpose**: Validates if building has available licenses

#### 10. `add_to_frequent_visitors()`
**Purpose**: Adds visitor to user's favorites list

#### 11. `create_emergency_alert()`
**Purpose**: Emergency notification system

#### 12. `daily_maintenance()`
**Purpose**: Automated maintenance tasks

---

## 🔄 Triggers

### Automatic Timestamp Management
```sql
-- Updates updated_at fields automatically
tr_[table]_updated_at: update_updated_at()
```
Applied to: `buildings`, `users`, `visitors`, `visits`, `frequent_visitors`, etc.

### License Management
```sql
-- Automatically tracks building license usage
tr_user_license_count: update_building_license_count()
```
**Behavior**:
- Increments `buildings.used_licenses` when user with `uses_license=true` is created
- Decrements when such user is deleted or moved
- Handles building transfers

### Visit Management
```sql
-- Updates visit visitor counts
tr_visit_visitor_count: update_visit_visitor_count()
```
**Behavior**:
- Increments `visits.current_visitors` when visitor added
- Decrements when visitor removed
- Handles visitor transfers between visits

### Auto-Completion
```sql
-- Automatically completes visits when all visitors exit
tr_auto_complete_visits: auto_complete_visits()
```
**Behavior**:
- Monitors `visit_visitors` status changes
- When all visitors have 'exited', marks visit as 'completed'
- Sets `actual_end` timestamp

### Security Auditing
```sql
-- Comprehensive audit logging
tr_[table]_audit: create_audit_log()
```
**Behavior**:
- Logs all CREATE, UPDATE, DELETE operations
- Captures before/after values
- Records user context and timestamps
- Applied to critical tables: `users`, `visits`, `visitors`, `visitor_bans`

### Analytics Collection
```sql
-- Real-time analytics data capture
tr_[table]_analytics: create_analytics_event()
```
**Behavior**:
- Captures business events (visit created, status changed, user login)
- Feeds real-time dashboard
- Enables pattern analysis

---

## 📊 Views

### 1. `visit_summary`
**Purpose**: Complete visit information with visitor details
```sql
SELECT * FROM visit_summary WHERE building_id = ?;
```
**Includes**: Visit details, host info, building info, visitor array (JSON)

### 2. `building_stats`
**Purpose**: Real-time building dashboard
```sql
SELECT * FROM building_stats WHERE building_id = ?;
```
**Includes**: License usage, resident count, visit statistics, emergency status

### 3. `user_activity_dashboard`
**Purpose**: User engagement metrics
```sql
SELECT * FROM user_activity_dashboard WHERE user_id = ?;
```
**Includes**: Visit counts, visitor relationships, notification status, online status

### 4. `visit_analytics`
**Purpose**: Time-series visit data for charts
```sql
SELECT * FROM visit_analytics 
WHERE building_id = ? AND visit_date >= ?
ORDER BY visit_date;
```
**Includes**: Daily aggregates, completion rates, visitor counts

### 5. `security_monitoring`
**Purpose**: Security dashboard for admins
```sql
SELECT * FROM security_monitoring WHERE building_id = ?;
```
**Includes**: Ban counts, active emergencies, overdue visits, audit events

### 6. Visitor Ban Views 🚫

#### `active_visitor_bans`
**Purpose**: Active visitor bans only (filtered view)
```sql
SELECT * FROM active_visitor_bans WHERE building_id = ?;
```
**Includes**: All active bans with complete ban details (excludes expired/inactive bans)

#### `building_ban_stats`
**Purpose**: Building-wide ban statistics and analytics
```sql
SELECT * FROM building_ban_stats WHERE building_id = ?;
```
**Includes**: 
- Total bans, active bans, severity breakdown
- Unique banned visitors count
- Users who have created bans
- Last ban date for trending

#### `user_ban_stats`
**Purpose**: Per-user ban statistics for residents
```sql
SELECT * FROM user_ban_stats WHERE user_id = ?;
```
**Includes**:
- Individual resident ban activity
- Total bans created, active bans
- High severity ban count
- Unique visitors banned
- First and last ban dates

### Materialized Views

#### `daily_visit_stats`
**Purpose**: Pre-computed daily statistics for performance
```sql
-- Refreshed automatically by daily maintenance
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_visit_stats;
```

---

## 🔐 Security

### Row Level Security (RLS)
**Enabled on**: `visits`, `visitors`, `notifications`, `frequent_visitors`, `visitor_bans`

#### Visit Access Policy
```sql
-- Users can only see their own visits or building visits if admin
CREATE POLICY visit_access_policy ON visits
USING (
    host_id = current_user_id() OR 
    building_id IN (
        SELECT building_id FROM users 
        WHERE id = current_user_id() 
        AND role IN ('building_admin', 'security', 'super_admin')
    )
);
```

#### Visitor Access Policy
```sql
-- Users can only see visitors from their building
CREATE POLICY visitor_access_policy ON visitors
USING (
    building_id IN (
        SELECT building_id FROM users 
        WHERE id = current_user_id()
    )
);
```

### User Context Function
```sql
-- Set by application for RLS policies
SELECT set_config('app.current_user_id', user_id::text, true);
```

### Authentication Role
```sql
-- Application users must have this role
GRANT authenticated_users TO application_user;
```

---

## ⚡ Performance

### Strategic Indexing
```sql
-- Core performance indexes
idx_visits_building_status (building_id, status)
idx_visits_qr_code (qr_code) -- Critical for gate scanning
idx_visitors_building_phone (building_id, phone) -- Visitor lookup
idx_visit_logs_timestamp (timestamp) -- Analytics queries
idx_notifications_user_unread (user_id, is_read) WHERE is_read = false
```

### Query Optimization
- **Composite indexes** for common filter combinations
- **Partial indexes** for filtered queries (e.g., unread notifications)
- **JSON indexes** for metadata searches (if needed)

### Materialized Views
- `daily_visit_stats`: Pre-computed daily aggregates
- Refreshed by `daily_maintenance()` function
- Enables fast dashboard loading

### Connection Recommendations
- **Connection pooling** (PgBouncer recommended)
- **Read replicas** for analytics queries
- **Partitioning** for high-volume tables (future consideration)

---

## 💡 Usage Examples

### Creating a Visit with Multiple Visitors
```sql
-- Host creates a group visit
SELECT * FROM create_visit_with_visitors(
    'building-uuid-here',
    'host-user-uuid',
    'Birthday Party',
    'Family birthday celebration for Sarah',
    '2024-01-20 15:00:00+01',
    '2024-01-20 22:00:00+01',
    '[
        {
            "name": "John Doe", 
            "phone": "+2348123456789", 
            "email": "john@example.com"
        },
        {
            "name": "Jane Smith", 
            "phone": "+2348987654321", 
            "email": "jane@example.com"
        },
        {
            "name": "Bob Wilson", 
            "phone": "+2348555666777"
        }
    ]'::jsonb,
    'group'
);

-- Returns QR code that covers all 3 visitors
```

### Gate Processing Workflow
```sql
-- 1. Security scans QR code
SELECT * FROM process_qr_scan('SG_ABC123DEF456', 'Gate A', security_officer_uuid);

-- Returns visit info + all expected visitors:
-- {
--   "visit_data": {
--     "visit_id": "...",
--     "title": "Birthday Party",
--     "host_name": "John Resident",
--     "apartment_number": "A101"
--   },
--   "visitors": [
--     {"name": "John Doe", "status": "expected"},
--     {"name": "Jane Smith", "status": "expected"}, 
--     {"name": "Bob Wilson", "status": "expected"}
--   ]
-- }

-- 2. Individual visitors arrive and enter
SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'arrived', 
    security_officer_uuid
);

SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'entered', 
    security_officer_uuid
);

-- 3. Visitors leave individually
SELECT * FROM update_visit_visitor_status(
    visit_uuid, 
    john_visitor_uuid, 
    'exited', 
    security_officer_uuid
);

-- 4. Visit auto-completes when all visitors exit
```

### Adding to Frequent Visitors
```sql
-- After a successful visit, host can save visitor to favorites
SELECT add_to_frequent_visitors(
    host_user_uuid,
    visitor_uuid,
    'My Brother John',
    'family',
    1  -- highest priority
);

-- Next time, host can quickly invite from favorites list
SELECT * FROM get_visitor_recommendations(host_user_uuid, 10);
```

### Visitor Ban Management Examples 🚫

#### Creating and Managing Bans
```sql
-- Create a visitor ban (would be done via API, shown for reference)
INSERT INTO visitor_bans (building_id, user_id, name, phone, reason, severity, ban_type, notes)
VALUES (
    'building-uuid',
    'user-uuid', 
    'John Problem Visitor',
    '+2348123456789',
    'Inappropriate behavior during last visit',
    'medium',
    'manual',
    'Resident requested permanent ban due to security concerns'
);

-- Check if visitor is banned by specific user
SELECT is_visitor_banned_by_user('user-uuid', '+2348123456789');

-- Check if visitor is banned anywhere in building
SELECT is_visitor_banned_in_building('building-uuid', '+2348123456789');

-- Create temporary ban with expiry
INSERT INTO visitor_bans (building_id, user_id, name, phone, reason, severity, expires_at)
VALUES (
    'building-uuid',
    'user-uuid',
    'Jane Temp Ban',
    '+2348987654321', 
    'Noise complaints from neighbors',
    'low',
    CURRENT_TIMESTAMP + INTERVAL '7 days'
);

-- Manually unban a visitor
UPDATE visitor_bans 
SET is_active = false,
    unbanned_at = CURRENT_TIMESTAMP,
    unban_reason = 'Issue resolved, apology accepted',
    unbanned_by = 'unbanning-user-uuid'
WHERE phone = '+2348123456789' 
AND user_id = 'banning-user-uuid'
AND is_active = true;
```

#### Ban Analytics and Monitoring
```sql
-- Get building ban statistics
SELECT * FROM building_ban_stats WHERE building_id = ?;

-- Get user's ban activity
SELECT * FROM user_ban_stats WHERE user_id = ?;

-- Monitor ban trends
SELECT 
    DATE(banned_at) as ban_date,
    COUNT(*) as bans_created,
    COUNT(*) FILTER (WHERE severity = 'high') as high_severity,
    COUNT(DISTINCT phone) as unique_visitors_banned
FROM visitor_bans 
WHERE building_id = ? 
AND banned_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(banned_at)
ORDER BY ban_date DESC;

-- Find visitors banned by multiple residents
SELECT 
    phone,
    name,
    COUNT(*) as ban_count,
    ARRAY_AGG(DISTINCT u.apartment_number) as banned_by_apartments,
    MAX(vb.severity) as highest_severity
FROM visitor_bans vb
JOIN users u ON vb.user_id = u.id
WHERE vb.building_id = ? AND vb.is_active = true
GROUP BY phone, name
HAVING COUNT(*) > 1
ORDER BY ban_count DESC;
```

#### Automated Ban Management
```sql
-- Run automatic ban expiry (for scheduled jobs)
SELECT expire_visitor_bans();

-- Check for expiring bans (within next 24 hours)
SELECT 
    name,
    phone,
    expires_at,
    CONCAT(u.first_name, ' ', u.last_name) as banned_by
FROM visitor_bans vb
JOIN users u ON vb.user_id = u.id
WHERE vb.is_active = true
AND vb.expires_at IS NOT NULL
AND vb.expires_at <= CURRENT_TIMESTAMP + INTERVAL '24 hours'
ORDER BY expires_at;
```

### Analytics Queries
```sql
-- Building dashboard data
SELECT 
    bs.*,
    va.total_visits as visits_today,
    sm.active_emergencies,
    bbs.total_bans,
    bbs.active_bans
FROM building_stats bs
LEFT JOIN visit_analytics va ON bs.building_id = va.building_id 
    AND va.visit_date = CURRENT_DATE
LEFT JOIN security_monitoring sm ON bs.building_id = sm.building_id
LEFT JOIN building_ban_stats bbs ON bs.building_id = bbs.building_id
WHERE bs.building_id = ?;

-- User activity summary with ban information
SELECT 
    uad.*,
    ubs.total_bans_created,
    ubs.active_bans,
    ubs.unique_visitors_banned
FROM user_activity_dashboard uad
LEFT JOIN user_ban_stats ubs ON uad.user_id = ubs.user_id
WHERE uad.building_id = ? 
ORDER BY uad.visits_this_week DESC;

-- Visit trends with ban correlation
SELECT 
    visit_date,
    total_visits,
    total_visitors,
    avg_visitors_per_visit,
    completed_visits::float / total_visits * 100 as completion_rate,
    COALESCE(ban_counts.daily_bans, 0) as bans_created
FROM visit_analytics va
LEFT JOIN (
    SELECT DATE(banned_at) as ban_date, COUNT(*) as daily_bans
    FROM visitor_bans 
    WHERE building_id = ? 
    GROUP BY DATE(banned_at)
) ban_counts ON va.visit_date = ban_counts.ban_date
WHERE va.building_id = ? 
AND va.visit_date >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY visit_date;
```

---

## 🔧 Maintenance

### Daily Maintenance
```sql
-- Run via cron job daily
SELECT * FROM daily_maintenance();

-- Tasks performed:
-- 1. Cleanup expired sessions and old notifications
-- 2. Archive old visits (>1 year)
-- 3. Refresh materialized views
-- 4. Update frequent visitor status
-- 5. Mark expired visits
```

### Manual Maintenance Tasks

#### Weekly License Review
```sql
-- Check license utilization across buildings
SELECT * FROM get_license_utilization() 
WHERE utilization_percentage > 80;
```

#### Monthly Performance Review
```sql
-- Table size analysis
SELECT * FROM get_table_stats() 
ORDER BY pg_total_relation_size DESC;

-- Slow query analysis (requires pg_stat_statements)
SELECT * FROM get_slow_queries('5 seconds'::interval);
```

#### Data Archival
```sql
-- Archive old completed visits
SELECT archive_old_visits(); 

-- Bulk update expired visits
SELECT bulk_update_visit_status(
    building_uuid,
    'pending'::visit_status,
    'expired'::visit_status,
    CURRENT_TIMESTAMP - INTERVAL '48 hours'
);
```

### Monitoring Recommendations

#### Health Checks
```sql
-- Monitor critical metrics
SELECT 
    COUNT(*) as active_visits,
    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) as visits_today
FROM visits 
WHERE status = 'active' AND building_id = ?;

-- License usage alerts
SELECT building_name, utilization_percentage 
FROM get_license_utilization() 
WHERE utilization_percentage > 90;
```

#### Performance Monitoring
- Monitor `visit_logs` growth rate
- Track QR scan response times
- Monitor materialized view refresh duration
- Alert on failed daily maintenance runs

---

## 🚀 Getting Started

### For New Developers

1. **Understand the Core Flow**:
   ```
   User creates visit → QR generated → Visitors scan QR → Individual tracking → Visit completion
   ```

2. **Key Tables to Focus On**:
   - `visits` (core entity)
   - `visitors` (reusable profiles)
   - `visit_visitors` (many-to-many relationship)

3. **Essential Functions**:
   - `create_visit_with_visitors()` - Visit creation
   - `process_qr_scan()` - Gate operations
   - `update_visit_visitor_status()` - Visitor tracking

4. **Common Queries**:
   - Use views for dashboard data
   - Use functions for business logic
   - Check RLS policies for data access

### Migration from Old System
If migrating from a visitor-centric system:
1. Export existing visitor data
2. Group visitors by time/host into visits
3. Generate visit records with associated visitors
4. Preserve visitor history and ratings

---

## 📚 Additional Resources

- **API Documentation**: See `/docs/api/` for REST and Socket endpoints
- **Business Logic**: Application layer handles QR generation and validation
- **Security**: See audit logs for all database changes
- **Performance**: Monitor slow queries and table growth
- **Backup**: Daily backups recommended with point-in-time recovery

---

This database schema provides a robust foundation for the SafeGuard visitor management system, with unlimited scalability for visitors while maintaining license control for registered users.
